# 压力测试

经过多次实验，改测试只能进行基础压测。因为游戏服务器本有很多行为取决于时间。因此服务器是一个有状态Stateful 服务器。而大规模压测只能针对不对前后状态有依赖的请求进行基准压测。

在服务器基础底层未改变的情况下，更多的基准压测的意义不大。

## 测试目的和期望的结果

模拟产品上线后大量用户进入，并进行**正常游戏**一定时间后的服务器表现。

正常游戏时间的要求，30分钟-1小时（待商榷）。

期望的测试结果：

- 采集服务器尽可能多的数据
    - 内存， CPU， 数据库容量， 数据库CPU
    - TCP链接的数量，系统资源占用，端口回收和重用的效果
    - 各个系统响应速度
- 发现服务器在高压力下的能力
    - 单服同时在线人数 - 决定服务器架构是否要做出相关修改
    - 最大存档人数 - 决定开新服与否
- 发现并解决高压下潜在的问题和Linux系统性能调优的需求



## 测试前提

1. 玩家所有和服务器的交互能够重新播放：目前玩家的随机数是可以固定的Seed，并且Rand的状态是保存在玩家存档中的。
所以，一个帐号，在采集行为的过程中，下线然后再上线，并不影响Seed的连续性。
1. 采集：玩家行为能够被准确的Log下来
  - Request的内容和间隔时间
  - Response的内容，能够容易的验证随机数一致性和算法稳定性
  - 玩家下线上线，能够更真实的模拟长时间玩家在线CCU的变化情况
1. 交互请求中没有使用其他人的帐号(0:0:1001)。因为相关请求不能够轻易批量化，类似的请求有，添加好友等


## 测试方法方案

目前整体思路学习golang开发的Gor， 这个软件能够实现TCP级别production流量回放。
Gor系统的log使用的是Gob编码的二进制流。但是对于玩家请求的分析最好能够使用Human-Readable的文本方案进行保存。但是文本方案在还原回请求数据包二进制的过程中不一定能够很完美[^json]。因此在每个log中会有一份json数据和对等的二进制数据的base64编码数据。

这样，在目前的这个log采集方案里我们不但可以用来记录**正确的请求序列**，还可以用来分析和重现那些带来问题的行为。因为我们可以分析文本的log，并从最后一个出问题的Request数据中发现问题所在。这将大大简化我们在QA和0.1.0公测阶段出现的问题的分析。

[^json]:  最方便的人类可读数据是json，但是json本身在数字数据的表达上是缺少具体类型的，因此最好能够保留二进制的log。

## 采集的数据格式

采集数据的Request格式

```
1430193418890465395 1430193418890465395 [Info] [RECORD] [1] [REQ] [0:0:1002], 888a3b82-acfb-4a26-8c56-c7dcaf89675b, PlayerAttr/SetPlayerAttributesRequest, json content of request, 100, base64(bin stream)
1430193418890465395 1430193418891872376 [Info] [RECORD] [1] [RSP] [0:0:1002], 888a3b82-acfb-4a26-8c56-c7dcaf89675b, PlayerAttr/SetPlayerAttributesResponse, json content of response, 100, base64(bin stream)
```

- 1430193418890465395：
  nanosecond，时间产生了两次，因为我们利用td-agent拆分玩家消息，但是td-agent读取时间后在输出中没有时间的key "time", 并且时间解析后是seconds精度，无法后续通过reformer还原, 因此正则解析第二个时间用来保证输出的拆分log中有正确的精度nanosecond.
  Request发送时间，用来计算每个Request之间的返送时间间隔
- [Info]：固定不变
- [RECORD]：代表这是一个游戏服务器交互记录
- [1]：带白哦这是一个Request&Response类型的服务器交互
- [REQ]: 这是一个Request信息
- [0:0:1002]：当前玩家的存档accountid, 压力测试中用不到
- 888a3b82-acfb-4a26-8c56-c7dcaf89675b：当前请求的passthrough id，用来分辨相关的Response的配对
- PlayerAttr/SetPlayerAttributesRequest 请求的名称
- string： 请求的json序列化内容
- 100：整个请求的二进制数据长度
- base64（bin stream）:
  请求的二进制内容，经过base64编码。可以通过这个还原出传输的Packet，便于机器人进行重放replay

TODO

- 采集的上下线数据，上下线时间点和具体的行为（彻底退出后回来，还是后台回来）
- 采集玩家建档初始随机种子

## 方案

- 内测阶段采集和压力的事
- 0.1.0开服后数据采集和重放:
  这个服务器的数据采集非常重要，因为真实的玩家行为，有利于更加准确的预估服务器压力。

在0.1.0的公开测试阶段如果每个玩家，每个帐号的随机值是固定可以预测的序列，就不是很好的行为了。
所以在随机数稳定的方案上，我们不得不记录每个玩家的初始Seed并输出到log中。已方便进行replay。


## 机器人行为的开发

能够读取采集来的玩家行为log进行回放，能够利用一个玩家的log模拟出更多的玩家行为，比如Request的访问间隔时间的scale处理，2倍速、4倍速，1/2倍速等等方式。

多个log组成一个玩家的具体行为[^multilog]。
如下是多个log代表一个玩家所有行文的文档的例子：

```
-rw-r--r-- 1 td-agent td-agent  13828 4月  28 15:10 0_0_1038.2015042814_0.log
-rw-r--r-- 1 td-agent td-agent 132157 4月  28 16:10 0_0_1038.2015042815_0.log
-rw-r--r-- 1 td-agent td-agent  14325 4月  28 17:10 0_0_1038.2015042816_0.log
-rw-r--r-- 1 td-agent td-agent  14689 4月  28 18:10 0_0_1038.2015042817_0.log
-rw-r--r-- 1 td-agent td-agent  15894 4月  28 19:10 0_0_1038.2015042818_0.log
-rw-r--r-- 1 td-agent td-agent  14548 4月  29 12:10 0_0_1038.2015042911_0.log
-rw-r--r-- 1 td-agent td-agent  16137 4月  29 15:11 0_0_1038.2015042914_0.log
-rw-r--r-- 1 td-agent td-agent   7274 4月  29 17:10 0_0_1038.2015042916_0.log
-rw-r--r-- 1 td-agent td-agent   8719 4月  29 18:10 0_0_1038.2015042917_0.log
-rw-r--r-- 1 td-agent td-agent 195886 4月  29 19:10 0_0_1038.2015042918_0.log
```

[^multilog]: 因为log太大时，log系统会对log进行适当的拆分

能够Auth&Login&Gate全线真实模拟

能够Gate独立压力模拟

能够Auth独立压力模拟

能够在更多的机器上模拟更多的玩家行为，难题是如何总体控制机器人集群对压测目标的测试策略。


