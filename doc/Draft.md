## Account

Account是属于游戏的每个分服的（Shard）。
所以下面对于Account的讨论都是指当前Shard的数据库中的Account。
并假设游戏有多个角色，多角色的信息是在Account里面的profile。
Account级别是有角色之间的共用数据的，例如HC，BagSize等，虽然在一定程度上是和Designer的游戏设计是相关的。


{gid}:{sid}:{user_id} 作为玩家帐号主account索引，主account里面如果有其他。
user_id的唯一性是是在game auth系统中保证唯一的。

* {accountid) == {gid}:{sid}:{user_id}
* {profileid}  == {gid}:{sid}:{user_id}:mage|warrior|... 二级存档信息拆分


* HSET account:{accountid) 
	* name {sid}.{nickname} //{sid} 需要自动标记在前面，客户端根据分合服情况不显示前缀
    * HC 100
    * Token0 100
    * Token1 101
    * BagSize 100
    * {mage|warrior|...} //json三个角色


* HSET profile:{profileid} 
	* hp 100
	* type mage
	* lvl 52
	* vip 0
	* etc.这里可以存储所有角色基本属性数据
	* energy 100
* SET {sid}.{nickname} {profileid} 玩家Nickname找到对方{profileid}， 这同时也是nickname是否重复的一个检测方法



## Friends 好友系统(profile级别)

*注意同时写保护*
保存当前角色和其他用户的好友关系以及好友关系属性。
每个人的好友上线数量需要限制，可能不同VIP或者级别不一样，根据游戏逻辑来定。建立一个独立的限制表格，如果没有默认限制表格，使用默认上限20

* 添加好友, 2 atom operations
* 删除好友, 2 atom operations

* 拒绝好友请求, 走Mail系统
* 发出好友请求, 走Mail系统
* 获取好友名单

对于以上需要2步原子操作的请求需要有机会修正[^TODO]

Redis数据设计
* SCARD friends:{profileid} 好友当前数量
* SADD friends:{profileid} {friend {profileid}} 如果需要设置额外的好友属性
* HMSET friend:{profileid}:{friend {profileid}}
	* mute 0/1
	* black 0/1
	* star 0/1


Redis数据设计(无Set[^noset])

[^noset]: SSDB 中没有set，支持hash, zset, list所以尝试将数据尽量限制在这三种类型中。

* HLEN friends:{profileid} 好友当前数量
* HSET friends:{profileid} {friend {profileid}} 0|1 值代表白名单或黑名单
* HDEL friends:{profileid} {friend {profileid}} 删除好友
* HGETALL HKEYS来获取当前好友列表
* HMSET friend:{profileid}:{friend {profileid}}
	* mute 0/1
	* star 0/1

### 体力互赠和邀请助阵[待定]

例如好友之间每天只能赠送一次体力，只能邀请一次助阵

体力互赠数据设计

* GET/SET friend:{profileid}:hphelp json{"{friend profileid}":lasthelp_unixtimestamp,}

邀请助阵数据设计

这个字符串在使用完后才再次生成一次。字符串中可能只有avatasid，也可能直接包括所有需要显示的数据缓存为了优化。

生成方式待定。。。[^TODO]

* GET/SET friend:{profileid}:fighthelp "{friend profileid}";"{friend profileid}"


## 通货和支付IAP

### 通货&Token

* 软通 SC{0} 数字代表不同类型的软通
* 硬通货 HC{0} 数字代表不同类型的软通。

部分通货可以只有INCR:

* 例如Tapjoy获取到的HC，需要一个总额的记录，甚至可能需要一个每次金额的记录。具体设计再议 [^TODO]
* IAP充值获得的HC数量决定了VIP级别

Redis数据设计(profile级别)

* HINCRBY profile:{profileid} HC{0} +/-100
* HINCRBY profile:{profileid} SC{0} +/-100

Redis数据设计(account级别)

* HINCRBY account:{accountid} HC{0} +/-100
* HINCRBY account:{accountid} SC{0} +/-100


### 通货收支记录


通常主要是指硬通货收支。方便客服使用。冷数据为主。

* 增长|减少
	* 流水ID
	* 时间
	* 数量
	* 原因

### 支付IAP

* 成功次数
* 充值对应总美金价值
* 每次充值的信息
	* 第几次
	* 每次的时间
	* bundle_id
	* transaction id
	* 充值类型(IOS|AndroidChannel|手工客服|Tapjoy)
	* SC/HC数量

这些数据可能需要保存到独立的支付数据库。多数情况为冷数据。因此也可以考虑保存到相关的log文件中，存放在类似S3的系统中。[^IAP1]

每个游戏服务器保存一个处理完成（数据库入账）的流水号。这个流水号码可以帮助在出现回档情况时进行IAP恢复！细节还需要完善。[^TODO]需要考虑支付数据库和游戏服务器之间的工作方式。

[^IAP1]: 如何让我们能够容易的知道哪些人是什么样的消费水平，和消费习惯？需要在那一部分数据中体现出来？

## Mail [account or profile级别]
*注意同时写保护*

1. 邮件的显示是需要时间顺序的
2. 邮件可以任意删除其中一个
3. 邮件的列表需要限制数量。数量达到上限后是无法接收邮件的。
4. 数据表可能出现删除邮件和生成邮件同时出现的情况
5. 需要考虑全服邮件的大规模群发情况


* 群发邮件
* 单发邮件
* 功能邮件
	* 好友请求
* 普通邮件
	* 	带奖励


Redis 数据库设计

* HSET mail:{profileid} hash(json{}) json{}
*

hash(json)的好处是可以防止邮件的重复发送。



json数据内容举例如下， type如果是text类型则只是一封普通邮件。

这是一个好友请求邮件的例子

```
{
	type:"friend",
	text:"utf-8 content---fdsafdsafds",
	params {
					friend_id:{profileid},
			  }
}
```

这是一个有奖励的邮件

```
{
	type:"gift",
	text:"utf-8 content---fdsafdsafds",
	params {
					items_id:10,
					items_id:20,
			  }
}
```


## Gift 奖励和补偿
*注意同时写保护*

**使用场景中，能够成为负载担忧的是玩家登录后会批量领取奖励。**

奖励分类：

1. 系统类奖励
	* 客服奖励和补偿
	* 充值返利活动
	* 礼品码获得奖励
1. 玩家触发
	* IAP购买奖励和促销奖励
	* 游戏中任务奖励 （有可能希望能够立即通过Popup获得）
	* 成就奖励（有可能希望能够立即通过Popup获得）

奖励接收系统类似一个特殊的Mail系统。但是根据奖品的不同类型的不同，有额外的技术要求。

* 发奖的时机
	* 离线计算发奖：通常采用离线计算后，然后玩家登录才能获得奖励
	* 后台定时计算，然后立即发奖。无论用户是否在线
	* 目标达成后立即发奖

此外，客服对于Gift系统也有一些额外的需求:

* 哪些玩家曾经收过哪些奖励，系统最好对所有内容一致的礼包都有唯一编号
* 玩家曾经使用过哪些礼品码，礼品码可以包含多个礼包
* 哪些奖励是否已经玩家使用了，如果可能相关流水号是否能查到
* 哪些奖励发放是因为奖励系统到达上限失效或者超过领取时间失效


### 礼包

* 可以包含任意种类任何数量的物品或者token
* 支持时效

KV模式hash(json:content):Json，保存在S3或者Redis Hash里面。
Json内容中包括了item和数量，失效时间，文本描述，文本标题。

**只要奖励的内容是一样的K就是一样的。文本内容因为可能因为各种原因需要修改添加，所以不计算在hash内。**

这样对客服系统应该是非常的方便。

Json部分保存在服务器配置数据库中，或者KV文件系统中，不会在每个收到奖励的玩家的Gift收件箱中浪费大量数据库内存。

```
{
	type:"iap返利",
	title:"恭喜或者重置返利",
	tille_en:"Congrats! IAP return",
	text:"",
	text_en:"",
	comments:"generated by Quest1",
	content
	{
		item_id: 10,
		item_id: 20,
	},
}
```
所有的礼品包是保存在Redis的配置Hash中

* HSET config:giftpackages hash(json:content) Json

### 礼品码

KV模式存放。K是礼品码需要批量生成然后发放给玩家或者（使用随机生成6位以上36进制串）。 V是UUID。
生成：生成后保存到Redis或者S3的KV系统中，获取一个删除一个。

* 礼品码：通常是媒体发放
	* 每个码唯一只能用一次，但是一个礼品码可能对应的都是同样的礼品包。
	* 有些礼品包终身只能获得一次 (好像没有必要搞了)

### 群发系统

多数使用场景是：

* 客服奖励和补偿
* 充值返利活动

**名单发奖**
**全服发奖**

#### 方案1：直接把奖品塞到用户的Gift系统收件箱中。[目前阶段优选]

好处：

* 发送简单
* 无论用户是否在线都能收到奖励
* 客服容易查看用户是否已经收到的相关的奖励和补偿

问题和注意：

需要计算奖励人数和奖励的数据量给数据库带来的负担。如果按照每个UUID 16 bytes计算。

100000 players x 100 UUID x 16 = 152Mbytes
20000 players x 500 UUID x 16 = 152Mbytes


####方案2：KV文件保存，用户属性保存已获取列表的方法

把奖品按照UUID保存到一个系统奖励的文件中，用户登录时检查并获取自己“已收”奖励列表中还没有的奖励，然后存放到Gift系统的收件箱中。

好处：

* 当用户级别特别大时，能够保证数据库中的活跃用户才会占用资源

问题和注意：

客服处理无法知道用户是否收到了补偿。用户很长时间后上线，老的奖励可能会出现无法获取的问题。（奖励机制bug，或者代码更新级别的遗忘）

不利于分服时整体移动奖励策略。


### 数据库设计

UUID 16bytes (补偿ID/活动ID 4bytes )-(4 bytes reserved)-(Gift内容唯一ID 4bytes)-(Suffix 4bytes)

Gift内容唯一ID：如下简称礼包ID

说明：

1. 考虑到，玩家在线可能有数据同时被多个角色同时写的可能性，决定采用Sorted Set。

2. 如果UUID直接暴露到客户端作为和客户端交互的一个凭证，是有风险的，所以如果保险起见，客户端和服务器交流使用的ID应该是用户唯一的。

3. 如果运营补偿发送一半发现问题，重新发送，由于ZADD本身会根据UUID更新当前Score,所以相同的礼物玩家无法收到多次。每日登录奖励中的奖励如果不使用就不赠送新礼包也能轻松实现。比如每日登录奖励体力。如果用户不使用，第二天奖励体力进行添加的时候，由于UUID是一样的，所以玩家不会再得到一个。

4. Suffix部分是对应特殊模块使用的参数，用来保证部分模块可能会反复出现的奖励
	* 连续购买了2个有奖励的IAP促销, 这里就填写玩家IAP的次数
	* Quest通关，反复刷，这里可以填写Quest次数


玩家Gift收件箱:只保存当前玩家收到的，但是还没有使用的奖励

* INCR giftc:{profileid} -> 101 客户端交互使用的ID，同时起到排序作用
  * Or HINCRBY profile:{profileid} gc 1
* 添加Gift: ZADD gifts:{profileid} 101 UUID
* 获取奖励列表数量：ZCARD gifts:{profileid}
* 获取奖励列表分页：ZRANGE gifts:{profileid} 0 pagenum*20
* 使用Gift并删除: ZREM gifts:{profileid} UUID

深入思考部分Edge Case

如何保存玩家获取过哪些奖励和补偿？这些数据本身都是冷数据么？
此外，如果希望实现“说明 3”里面的“重新发送但是玩家不会重复收到”，还要考虑一种特殊情况。比如，第一次发送到一半，出现问题，然后部分玩家已经领取了这个奖励。因为奖励一旦领取应该从这个集合中移除。一旦移除这个UUID(包含礼包ID)，就意味着，“说明3”希望实现的东西没有那么容易。

如果每次发送奖品都需要去额外一个集合去检查存在性，是可行的。但是值得为这个edge case实现一个额外的数据集合么？一个玩家一生需要的多少礼包？这个集合的数据似乎使用冷热数据的事项方式更为经济，冷数据保存这个集合的时候，可以是保存在一个KV文件系统中。

客服系统还需要额外的信息（发放时间，使用时间等），所以客服系统需要读取一部分冷数据和能够查看热数据的能力。


## 其它奖励系统
*(需要进一步设计)*
这里的奖励都直接按照内容进行奖励，客服可能无法详查？

### Gameplay

* 每日登录奖励
	* 不能累积的，例如体力药瓶，不登录不实用，奖品里就只有一个
	* 能够累积的，。。。。[^TODO]
* Quest奖励
* 邀请码：使用邀请码来的用户双方都额外获得礼品礼包



## Inventory (Bag)

定义使用方式：
* 背包有数量限制，用户可以购买上限。不同用户的上限可能不一样。
* 背包中每个格子可以保存：物品（ID）x数量


* 背包格子读写通常不会有并发写问题：HSET profile:{profileid} bagsize 100
* 背包使用HASH保存，实际上是没有上限的，但是考虑到性能，如果能够在512以内是最好的。VIP玩家到512以上也没问题。
	* 背包的Hash Key=ItemID or Hash(ItemID)
	* 添加增加新物品 HINCRBY bag:{profileid} Hash(ItemID) 15
	* 使用消耗物品
		* HGET bag:{profileid} Hash(ItemID) 然后比较大小后
		* HINCRBY bag:{profileid} Hash(ItemID) -5
		* 物品数量为0后删除 HDEL bag:{profileid} Hash(ItemID)
	* 获取Bag中物品列表
		*  HGETALL bag:{profileid}
		*  HSCAN?

**Key 的深入讨论**

Hash的主要目的是降低ItemID的编辑心智负担，统一ID长度，便于估算数据使用量。但是需要客服工具需要隐藏这个细节。

但是如果背包需要提供物品分类显示的功能，就需要在Hash前面加上分类前缀(固定长度)，或者直接使用ItemID中的前缀就比较简单了

## Store

* cfg:store0
* cfg:store1
* cfg:store2
* cfg:storex
*
不是玩家存档数据，属于配置数据。需要考虑各种不同的Store。
可以考虑直接存成Set, 然后每个Item是一个json或者如下字符串
``
icon, price(sc, hc), discount, text(itemid), title.
``


* 稳定Store：可以理解为填充数值和算法是稳定的，甚至是从游戏Excel表格copy过来的
* 不稳定Store：需要运营数据和运营填充**算法**，也可能每个人都不一样，每次玩家打开有几个是固定的，有一些是随机的。Store里面的内容也可以是全是随机的。玩家可以刷新，免费的有次数限制，然后都是需要付费的。

## Leaderboard

> 陌陌争霸中用于排名的分数区间不大，也就是 0 分到 5000 分。而参与排名的人数众多，数以百万计。对百万用户做插入排序，每个插入即使是 O(N) 的也不可接受。可事实是大量玩家的分数相同，都是并列排名的。所以我们只需要做 5000 个桶，每个桶里仅记录这个分数有多少个人就可以了。
当玩家分数变迁，把原来的桶减一，新的桶加一。这个操作就是 O(1) 的。
>
而排行榜的查询仅需要把当前分数靠前的桶累加，就能获知查询者的名次。对于上百万玩家，看到哪些人和你并列的人的名字是没有意义的。这个查询虽然是 O(n) 复杂度，但 n 只有区区 5000 ，还可以做 cache 以应对查询频率远高于更新频率的情况。
>
真正需要精确知道人名的是榜单的前 200 个人，而对前 200 个人做插入排序也很快，所以并不会造成性能问题。

## 命名系统

HyperLoglog能够用来帮助命名不重复的检测么？
nickname如何不重复？公会名字如何不重复？


## 公告系统

## 公会


## Skill 技能升级

## Fuse&Evolution

## Quest&Event

## Gacha

##


[^TODO]: 一个未完成问题
