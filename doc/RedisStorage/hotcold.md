# 冷热数据 白皮书

## 冷热数据的思考

从冷热数据的角度考虑玩家的类型，通过玩家的类型区分存档的存在类型。
- 活跃玩家
- 不活跃玩家
- 流失的玩家

对于活跃和不活跃玩家的区分，需要一个或者几个阈值来进行区分。
- N日内没有任何一次登录的玩家
- M日内登录日数少于X日
- 是否是付费用户

目前我们只考虑第一个条件：N=7, 7日内没有任何一次登录的玩家定义为不活跃玩家.
流失玩家，是由不活跃玩家数据被“冷”处理后，再也没有激活成热数据的玩家。
热数据：在游戏服务器的Redis服务器内存里。
冷数据：已经从Redis内存中保存到其他大型数据库（Mysql， SSDB, MongoDB, S3, DynamoDB etc.）
## 如何记录并判断玩家的活跃度

如下三个问题中的其中一个？
- 如何生成活跃玩家列表
- 如何生成不活跃玩家列表
- 是否为活跃/不活跃玩家的查询

找出活跃玩家的数据来源
- Auth DynamoDB中记录玩家最后登录的时间 (可以用来慢慢Scan)
- 玩家登录日志
- S3上玩家按日分隔的登录玩家存档备份
- 创建独立的Redis，用TTL实现活跃玩家的列表自动维护

### 利用独立的Redis记录玩家活跃度

在一个独立的Redis中，所有登录过的玩家都有一个TTL Key，TTL时长为N日。
每次玩家登录，都会重设这个值的TTL。
当TTL过期时，通过Key Space Notification发送信息到SQS, 然后冷化数据的Worker开始工作。
当然，Key Space Notification是依赖Pub/Sub实现的，所以当任何意外出现时，过期的TTL是可能无法被发送到SQS里面。但是这本身应该是很少出现的一种情况。
这个Redis的Key值，还可以作为非实时异步运维的一个数据参考，即存在数据库中的值，就是活跃玩家。那么可以利用O(1)的查询操作，实现对玩家是否为活跃玩家一个判断数据库。
有了这个数据库的keys列表，也可以：
1. 冷化所有数据到S3
2. 利用这个数据库里面的Key,把活跃玩家的存档主动热化

当然，我们可以更懒一点，玩家自己登录的自然就热化了数据。只不过如果数据库的读取性能如过跟不上玩家的热情，玩家的登录体验将不会太好。
如果每个玩家的Key是0:0:1001的样子，我们可以简单计算出这个Redis数据库内存中占用的大小。
```
M = SizeOfKey + SizeOfTTL
TODO:利用python维护redis的库计算准确的值
```

可能每个游戏都很难准确估算出自己到底最后有多少CCU。最好的方式是我们部署一个这样的数据库，然后根据最近N天的运营效果来估算。当然，也存在可能是这个数据库单点最大也无法支撑你的CCU。
解决方案还是有的：
1. 根据GameId进行切分Redis

2. 使用SSDB，需要计算容量后测试TTL

3. 写一个REST API或者Redis proxy[^shardproxy]，或者干脆Codis?

   [^shardproxy]: 可以参考一个[Replaction Reshard的golang实现](https://github.com/smira/redis-resharding-proxy)


### 利用S3用来找出最近活跃玩家

我们开发的RedisStorage工具，具有按天分类每天上线玩家存档备份的能力。因此这些存档本身就代表了哪些玩家是活跃玩家。
如果我们可以使用S3上的数据生成活跃玩家列表，我们就能够容易的利用S3这个免维护的大系统实现不活跃玩家数据冷化处理。例如利用Hadoop计算S3上的玩家出现频率。
但是利用S3上的数据进行分析，有一些麻烦的地方，就是是遍历大量S3 Key的性能问题，也许利用AWS的EMR（hadoop）能够解决这个性能问题。
这个方案貌似是最理想的方式，因为我们为了保证玩家的存档能够安全备份的附加产品，此外S3的免维护和无限容量是亮点。
### 利用ElasticSearch来找出最近活跃玩家

玩家登录信息日志，是玩家行为的重要日志，通常我们记录玩家每一次登录的日志。这些日志如果输出到ElasticSearch后，是否能够利用ElasticSearch的卓越性能实现在线活跃玩家的列表生成？
TODO


## 热化数据

热化行为的两种可能：
主动热化：由开发运维团队主动触发，把在冷数据库中的玩家存档主动读取到Redis内存中的行为。通常在停机下发生。
被动热化：或者成为自然热化激活。当数据冷化后，玩家回来需要继续游戏时，游戏服务器收到玩家将要登录的通知时，需要在handshake成功返回前，实现数据加载到Redis(主数据库)的热化操作。
完全依赖被动热化行为，能够大量减少运维工作量，但是本身对玩家的体验和保存冷化数据的数据库的IO能力可能有较高的要求。所以我们运维需要尽量主动热化活跃玩家的存档数据。

## 运维和运营的思考

### 运维

对于每一个Shard， 在开服的N日内是不需要进行数据冷化的。因此，开发团队需要方法保证一个Shard在开服N日内能够支撑足够多的用户数据存储。
或者在一个Shard使用的数据库到达一个阈值时，果断进行开新服处理，控制活跃玩家的数量在数据库能够承受的范围内。
### 运营

目前能够想到可能受到影响的系统是：
- 冷数据存档如何应对发奖、发物资等行为的处理?
  - 应该对于冷数据或者热数据都是无差别友好的（独立与主Redis数据库外的每个玩家的独立队列）
- 玩家存档查询的行为和GMTools如何处理冷数据？
  1. 读取查看—回滚读取
  2. 修改行为
     1. 阻止玩家上线
     2. 直接修改对应数据(Redis，S3)

  ​

## 目前选择的实现

- 分析哪些数据应该冷化，如何分析哪些数据应该冷化
- 如何进行冷化操作(冷化（读取，写S3, 删除）)
- 热化
- 分析边界条件(固定容量存档，时间增长存档)
